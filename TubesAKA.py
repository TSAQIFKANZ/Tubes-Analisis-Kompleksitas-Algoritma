# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zw0c4FRu7WuOrJTfm8OPY9Xl81gGFg13
"""

import time
import matplotlib.pyplot as plt
import random
import pandas as pd

# Iterative approach to find the optimal hotel based on criteria
def find_optimal_hotel_iterative(hotels, key):
    optimal_hotel = hotels[0]
    for hotel in hotels:
        if key(hotel) < key(optimal_hotel):
            optimal_hotel = hotel
    return optimal_hotel

# Recursive approach to find the optimal hotel based on criteria with a helper function to avoid recursion depth issues
def find_optimal_hotel_recursive(hotels, key):
    def helper(index, optimal):
        if index == len(hotels):
            return optimal

        if optimal is None or key(hotels[index]) < key(optimal):
            optimal = hotels[index]

        return helper(index + 1, optimal)

    return helper(0, None)

# Criterion function
def criterion(hotel):
    return hotel['distance']

# Performance testing
sizes = [1, 10, 100, 1000, 5000]
results_iterative = []
results_recursive = []

for size in sizes:
    hotels = [{"name": f"Hotel {i}", "size": random.randint(10, 500), "distance": random.randint(1, 100)} for i in range(size)]

    # Test iterative version
    start_time = time.time()
    find_optimal_hotel_iterative(hotels, criterion)
    results_iterative.append(time.time() - start_time)

    # Test recursive version
    start_time = time.time()
    find_optimal_hotel_recursive(hotels, criterion)
    results_recursive.append(time.time() - start_time)

# Create a DataFrame for comparison
data = {
    "Input Size": sizes,
    "Iterative Time (s)": results_iterative,
    "Recursive Time (s)": results_recursive
}
df = pd.DataFrame(data)
print(df)

# Plotting results
plt.plot(sizes, results_iterative, label='Iterative')
plt.plot(sizes, results_recursive, label='Recursive')
plt.xlabel('Input Size')
plt.ylabel('Time (s)')
plt.title('Running Time Comparison')
plt.legend()
plt.show()